package main

import (
	"fmt"
	"math/rand"
	"time"
)

func goroutines() {
	// Горутины похожи на потоки, но они управляются самим Go,
	// а не операционной системой. Код, который запускается как горутина,
	// может работать одновременно с другим кодом.
	// Современное железо позволяет запустить порядка миллиона горутин.

	// горутина, которая имеет данные, может передать их в другую горутину
	// с помощью канала. В результате, в любой момент времени только одна
	// горутина имеет доступ к данным.
	// единственное общее состояние, которое мы можем безопасно получать
	// и отправлять одновременно – это канал.

	c := make(chan int) // канал для передачи целых чисел

	for i := 0; i < 5; i++ {
		worker := &Worker{id: i}
		go worker.process(c)
	}
	time.Sleep(time.Millisecond * 2000)

	// Go гарантирует, что данные, отправляемые в канал,
	// будут приняты только одним получателем.
	c <- rand.Intn(100) // CHANNEL <- DATA отправляем в канал
	time.Sleep(time.Millisecond * 2000)
}

type Worker struct {
	id int
}

// отправка и прием данных являются блокирующими операциями
// во время получения данных из канала выполнение горутины
// останавливается пока данные не доступны. Аналогично когда мы отправляем
// в канал, выполнение не продолжается пока данные не получены.
func (w *Worker) process(c chan int) {
	fmt.Printf("обработчик %d listening...\n", w.id)
	data := <-c // VAR := <-CHANNEL получаем из него
	// execution continues after we got some data through channel
	fmt.Printf(" - обработчик %d получил %d\n", w.id, data)
}
